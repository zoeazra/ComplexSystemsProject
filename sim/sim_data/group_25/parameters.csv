{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# **Stochastic Simulation Assignment 2**\n",
    "\n",
    "---\n",
    "\n",
    "\n",
    "### **Contributors**  \n",
    "- **Maarten Stork**  \n",
    "- **Paul Jungnickel**  \n",
    "- **Lucas Keijzer**\n",
    "\n",
    "### **Overview**  \n",
    "This notebook contains the code and analysis for **Assignment 2 of Stochastic Simulation**. The code follows the order specified in the assignment guidelines and replicates the experiments conducted in the referenced paper. Each section corresponds to (a) key experiment(s)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Imports\n",
    "import simpy\n",
    "import queue\n",
    "import numpy.random as rand\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "from scipy import stats\n",
    "from scipy.stats import mannwhitneyu\n",
    "from scipy.stats import kruskal\n",
    "from stochasticQueueing import *"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "\n",
    "## 2nd Question: Experiments with Varying Server Numbers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The following code block provides Python functions to simulate various queueing systems and compute key performance metrics. It includes implementations for queue simulations, Erlang B formula calculations, waiting probabilities, and expected waiting times."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def M_M_n_simulation(system_load, server_count, sim_duration, seed=42, queue_type='FIFO', warmup_duration=0):\n",
    "    \"\"\"\n",
    "    Simulates an M/M/n queueing system.\n",
    "\n",
    "    Parameters:\n",
    "    - system_load: The load factor of the system (λ/μ).\n",
    "    - server_count: The number of servers in the system.\n",
    "    - sim_duration: The duration of the simulation.\n",
    "    - seed: Seed for the random number generator to ensure reproducibility (default is 42).\n",
    "    - queue_type: Type of queue (default is 'FIFO').\n",
    "    - warmup_duration: duration after which to start counting the statistics\n",
    "\n",
    "    Returns:\n",
    "    - sim.results(): Results of the queueing simulation.\n",
    "    \"\"\"\n",
    "\n",
    "    # Set arrival and service rates\n",
    "    arrival_rate = server_count\n",
    "    service_rate = 1 / system_load\n",
    "\n",
    "    arrival_dist = lambda: rand.exponential(1 / arrival_rate)\n",
    "    service_dist = lambda: rand.exponential(1 / service_rate)\n",
    "\n",
    "    # Initialize and run the simulation\n",
    "    sim = ServerQueueingSimulation(\n",
    "        arrival_dist, service_dist, server_count, queue_type=queue_type, sim_duration=sim_duration, warmup_duration=warmup_duration, seed=seed\n",
    "    )\n",
    "    return sim.results()\n",
    "\n",
    "\n",
    "\n",
    "def B(c, rho):\n",
    "    \"\"\"\n",
    "    Recursively calculates the Erlang B formula.\n",
    "\n",
    "    Parameters:\n",
    "    - c: The number of servers.\n",
    "    - rho: The traffic intensity (λ / μ).\n",
    "\n",
    "    Returns:\n",
    "    - The probability of all servers being busy (blocking probability).\n",
    "    \"\"\"\n",
    "    if c == 0:\n",
    "        return 1\n",
    "    Bprev = B(c-1, rho)\n",
    "\n",
    "    return (rho * Bprev) / (c + rho * Bprev)\n",
    "\n",
    "def PiW(c, rho):\n",
    "    \"\"\"\n",
    "    Calculates the probability of waiting in the queue.\n",
    "\n",
    "    Parameters:\n",
    "    - c: The number of servers.\n",
    "    - rho: The traffic intensity per server (λ / μ / c).\n",
    "\n",
    "    Returns:\n",
    "    - The probability that a customer has to wait.\n",
    "    \"\"\"\n",
    "    Bprev = B(c-1, c * rho)\n",
    "    return (rho * Bprev) / (1 - rho + rho * Bprev)\n",
    "\n",
    "def expectedWaitingTime(c, rho):\n",
    "    \"\"\"\n",
    "    Calculates the expected waiting time in the queue.\n",
    "\n",
    "    Parameters:\n",
    "    - c: The number of servers.\n",
    "    - rho: The traffic intensity (λ / μ).\n",
    "\n",
    "    Returns:\n",
    "    - The expected waiting time for a customer.\n",
    "    \"\"\"\n",
    "    if c == 1:\n",
    "        return rho ** 2 / (1 - rho)\n",
    "    else:\n",
    "        Pi = PiW(c, rho)\n",
    "        return Pi / ((1 - rho) * (c / rho))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## plots for $\\rho$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "server_counts = [1, 2, 4]\n",
    "num_runs = 20\n",
    "rand.seed(42)\n",
    "system_loads = np.linspace(0.4,0.99, 10)\n",
    "durations = 100000*np.ones_like(system_loads)\n",
    "durations[7:] *=5\n",
    "\n",
    "def vary_rho():\n",
    "    \"\"\"\n",
    "    compute the mean waiting time with the local variables above as parameters\n",
    "    and a warmup time of 90 percent of the total duration\n",
    "    save the computed values as a compressed file\n",
    "    \"\"\"\n",
    "    wait_time_measurements = np.zeros([len(durations), len(system_loads), num_runs])\n",
    "    mean_wait_time = np.zeros([len(durations), len(system_loads)])\n",
    "    std_wait_time = np.zeros([len(durations), len(system_loads)])\n",
    "    for N, server_count in enumerate(server_counts):\n",
    "        for i, system_load in enumerate(system_loads):\n",
    "            for j in range(num_runs):\n",
    "                \n",
    "                res = M_M_n_simulation(system_load, server_count, sim_duration=durations[i], warmup_duration=0.9*durations[i], seed=rand.randint(0,2**31-1))\n",
    "                wait_time_measurements[N, i, j] = res['Average Wait Time']\n",
    "\n",
    "            mean_wait_time[N, i] = np.mean(wait_time_measurements[N,i,:])\n",
    "            std_wait_time[N, i] = np.std(wait_time_measurements[N,i,:])\n",
    "        # plt.plot(1 - system_loads, mean_wait_time, label=f'{server_count}')\n",
    "        print(server_count, 'done')\n",
    "\n",
    "    np.savez('data/servcount.npz', mean_wait_time, std_wait_time, wait_time_measurements)\n",
    "\n",
    "# This code takes roughly 45 minutes to run\n",
    "# vary_rho()\n",
    "\n",
    "# Instead, you can load the data from a previous run\n",
    "\n",
    "arrays = np.load('data/servcount.npz')\n",
    "mean_wait_time, std_wait_time, wait_time_measurements= arrays['arr_0'], arrays['arr_1'], arrays['arr_2']\n",
    "\n",
    "\n",
    "for N, server_count in enumerate(server_counts):\n",
    "    \n",
    "    plt.errorbar(system_loads, mean_wait_time[N], 1.96*std_wait_time[N]/np.sqrt(num_runs), linestyle='', label=f'{server_count}', capsize=5, elinewidth=1)\n",
    "\n",
    "\n",
    "plot_loads = np.linspace(system_loads[0], system_loads[-1], 1000)\n",
    "for c in server_counts:\n",
    "    plt.plot(plot_loads, expectedWaitingTime(c, plot_loads), linestyle=':', color='grey')\n",
    "plt.grid()\n",
    "# plt.xscale('log')\n",
    "plt.yscale('log')\n",
    "plt.xlabel(r'$\\rho$', fontsize=14)\n",
    "plt.ylabel('mean wait time', fontsize=14)\n",
    "plt.xticks(fontsize=12) \n",
    "plt.yticks(fontsize=12) \n",
    "plt.legend(title='server count', fontsize=12)\n",
    "# plt.savefig('plots/2).png', dpi=600)\n",
    "\n",
    "\n",
    "\n",
    "# Lines for computing the statistical tests\n",
    "\n",
    "wait_time_measurements = wait_time_measurements[:3].reshape([3,-1])\n",
    "\n",
    "print('Performing pair-wise Mann-Whitney U tests:')\n",
    "u, p = stats.mannwhitneyu(wait_time_measurements[0], wait_time_measurements[1])\n",
    "print('1 vs 2 servers, U = ', u, 'p = ', p)\n",
    "\n",
    "u, p = stats.mannwhitneyu(wait_time_measurements[0], wait_time_measurements[2])\n",
    "print('1 vs 4 servers, U = ', u, 'p = ', p)\n",
    "\n",
    "u, p = stats.mannwhitneyu(wait_time_measurements[1], wait_time_measurements[2])\n",
    "print('2 vs 4 servers, U = ', u, 'p = ', p)\n",
    "\n",
    "h, p = stats.kruskal(wait_time_measurements[0], wait_time_measurements[1],wait_time_measurements[2])\n",
    "print('Kruskal-Wallis H-statistic, H = ', h, 'p = ', p)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Convergence of the MWT with simulation duration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Parameters used\n",
    "server_count = 1\n",
    "run_count = [1000, 1000,200, 200,50, 50,20, 20, 10,5]\n",
    "rand.seed(42)\n",
    "system_loads = [0.2, 0.5, 0.8, 0.9, 0.99, 0.999]\n",
    "max_duration = np.logspace(3, 7, 10)\n",
    "\n",
    "def vary_duration():\n",
    "    \"\"\"\n",
    "    compute the mean waiting time with the local variables above as parameters\n",
    "    and a warmup time of 90 percent of the total duration\n",
    "    save the computed values as a compressed file\n",
    "    \"\"\"\n",
    "    mean_wait_time = np.zeros([len(system_loads), len(max_duration)])\n",
    "    std_wait_time = np.zeros([len(system_loads), len(max_duration)])\n",
    "\n",
    "    # Run simulations for different system loads\n",
    "    for l, system_load in enumerate(system_loads):\n",
    "        for i, duration in enumerate(max_duration):\n",
    "\n",
    "            num_runs = run_count[i]\n",
    "            \n",
    "            wait_times = np.zeros(num_runs)\n",
    "            for j in range(num_runs):\n",
    "                \n",
    "                res = M_M_n_simulation(system_load, server_count, duration, seed=rand.randint(0,2**31-1), warmup_duration=0.9*duration)\n",
    "                wait_times[j] = res['Average Wait Time']\n",
    "\n",
    "            mean_wait_time[l,i] = np.mean(wait_times)\n",
    "            std_wait_time[l,i] = np.std(wait_times)\n",
    "            print('.')\n",
    "        print(system_load, np.mean(std_wait_time[-1]))\n",
    "\n",
    "    np.savez('data/duration-convergence-2.npz', mean_wait_time, std_wait_time)\n",
    "\n",
    "\n",
    "#this also takes over 30 minutes to run, but data from previous run is saved in repo\n",
    "# vary_duration()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# load data\n",
    "arrays = np.load('data/duration-convergence-2.npz')\n",
    "mean_wait_time, std_wait_time = arrays['arr_0'], arrays['arr_1']\n",
    "\n",
    "# create plot\n",
    "plt.figure(constrained_layout=True)\n",
    "\n",
    "for l, system_load in enumerate(system_loads):\n",
    "\n",
    "    plt.errorbar(max_duration, mean_wait_time[l], 1.96*std_wait_time[l]/np.sqrt(run_count[l]), linestyle='',  label=f'{system_load}', capsize=5, elinewidth=1)\n",
    "\n",
    "# Configure plot\n",
    "plt.tight_layout()\n",
    "plt.grid()\n",
    "plt.ylim(0.011,10000)\n",
    "plt.xscale('log')\n",
    "plt.yscale('log')\n",
    "plt.xlabel(r'simulation duration', fontsize=14)\n",
    "plt.ylabel('mean wait time', fontsize=14)\n",
    "plt.xticks(fontsize=12) \n",
    "plt.yticks(fontsize=12) \n",
    "plt.legend(title='system load', loc=2, ncols=3, fontsize=12)\n",
    "plt.savefig('plots/duration-0.9-warmup.png', dpi=600 )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "\n",
    "## 3d Question: Experiments with Different Queue Disciplines (FIFO vs SFJ)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The following code block implements a comparison between the **Shortest Job First (SJF)** and **First In, First Out (FIFO)** scheduling policies in an \\(M/M/n\\) system. It simulates waiting times across varying system loads (\\(\\rho\\)) and evaluates statistical differences between the two policies. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define parameters\n",
    "rand.seed(42)\n",
    "\n",
    "def comparison_SJF_FIFO(system_loads = np.linspace(0.4, 0.99, 20), num_runs = 100, server_counts = [1]):\n",
    "    \"\"\"\n",
    "    Compares Shortest Job First (SJF) and First In First Out (FIFO) policies in an M/M/n system.\n",
    "\n",
    "    Parameters:\n",
    "    - system_loads: Array of system loads (ρ = λ/μ) to test (default: 0.4 to 0.99).\n",
    "    - num_runs: Number of simulation runs per load (default: 100).\n",
    "    - server_counts: List of server counts to evaluate (default: [1]).\n",
    "\n",
    "    Returns:\n",
    "    - waiting_times: Dictionary of waiting times for each policy across all simulations.\n",
    "    \"\"\"\n",
    "    # Store waiting times for each queue type\n",
    "    waiting_times = {queue_type: [] for queue_type in ['FIFO', 'SJF']}\n",
    "\n",
    "    # Run simulations for each queue type\n",
    "    for queue_type in ['FIFO', 'SJF']:\n",
    "        mean_wait_time = np.zeros_like(system_loads)\n",
    "        std_wait_time = np.zeros_like(system_loads)\n",
    "        for i, system_load in enumerate(system_loads):\n",
    "            wait_times = []\n",
    "            for j in range(num_runs):\n",
    "                res = M_M_n_simulation(\n",
    "                    system_load, server_counts[0], 1000, seed=rand.randint(0, 2**31 - 1), queue_type=queue_type\n",
    "                )\n",
    "                wait_times.append(res['Average Wait Time'])\n",
    "\n",
    "            # Store waiting times for later statistical testing\n",
    "            waiting_times[queue_type].extend(wait_times)\n",
    "\n",
    "            # Calculate mean and std deviation\n",
    "            mean_wait_time[i] = np.mean(wait_times)\n",
    "            std_wait_time[i] = np.std(wait_times)\n",
    "\n",
    "        # Plot mean waiting times with error bars\n",
    "        plt.errorbar(\n",
    "            system_loads,  # Plotting against rho\n",
    "            mean_wait_time,\n",
    "            std_wait_time / np.sqrt(num_runs),  # 95% confidence intervals\n",
    "            linestyle='',\n",
    "            label=f'{queue_type}',\n",
    "            capsize=5,\n",
    "            elinewidth=1,\n",
    "        )\n",
    "\n",
    "    # Configure plot\n",
    "    plt.grid()\n",
    "    plt.yscale('log')\n",
    "    plt.xlabel(r'$\\rho$', fontsize=14) \n",
    "    plt.ylabel('Mean Wait Time', fontsize=14) \n",
    "    plt.xticks(fontsize=12) \n",
    "    plt.yticks(fontsize=12) \n",
    "    plt.legend(title='Queue Type', title_fontsize=12, fontsize=12)\n",
    "    \n",
    "    # show plot\n",
    "    plt.show()\n",
    "\n",
    "    # return the waiting times for different system loads\n",
    "    return waiting_times\n",
    "\n",
    "\n",
    "waiting_times = comparison_SJF_FIFO()\n",
    "print(f\"FIFO mean:{np.mean(waiting_times['FIFO'], axis= 0)}, std: {np.std(waiting_times['FIFO'], axis= 0)}\")\n",
    "print(f\"SJF mean:{np.mean(waiting_times['SJF'], axis= 0)}, std: {np.std(waiting_times['SJF'], axis= 0)}\")\n",
    "\n",
    "# Perform Mann-Whitney U-test\n",
    "u_stat, p_val = mannwhitneyu(waiting_times['FIFO'], waiting_times['SJF'], alternative='two-sided')\n",
    "print(f\"Mann-Whitney U-test: U-statistic = {u_stat:.4f}, p-value = {p_val:.4e}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "\n",
    "## 4th Question: Different Service Rate Distributions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This code block simulates queueing systems with various service time distributions. It models an \\(M/X/n\\) queueing system to evaluate how different service distributions impact waiting times across varying system loads. The results include graphical representations and statistical analyses to compare performance under different conditions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def M_X_n_simulation(system_load, server_count, sim_duration, seed=None, service_dist=None):\n",
    "    \"\"\"\n",
    "    Simulates an M/X/n queueing system.\n",
    "\n",
    "    Parameters:\n",
    "    - system_load: The load factor of the system (λ/μ).\n",
    "    - server_count: The number of servers in the system.\n",
    "    - sim_duration: The duration of the simulation.\n",
    "    - seed: Seed for the random number generator to ensure reproducibility (default is None).\n",
    "    - service_dist: Custom service distribution (default is exponential).\n",
    "\n",
    "    Returns:\n",
    "    - sim.results(): Results of the queueing simulation.\n",
    "    \"\"\"\n",
    "\n",
    "    if seed is not None:\n",
    "        rand.seed(seed)\n",
    "\n",
    "    # Set arrival rate and job completion rate\n",
    "    arrival_rate = server_count\n",
    "    job_completion_rate = 1 / system_load\n",
    "    \n",
    "    arrival_dist = lambda: rand.exponential(1 / arrival_rate)\n",
    "\n",
    "    # Use default exponential service distribution if none is provided\n",
    "    if service_dist is None:\n",
    "        service_dist = lambda: rand.exponential(1 / job_completion_rate)\n",
    "\n",
    "    # Initialize and run the simulation\n",
    "    sim = ServerQueueingSimulation(arrival_dist, service_dist, server_count, sim_duration=sim_duration, seed=seed)\n",
    "    \n",
    "    return sim.results()\n",
    "\n",
    "def run_simulations_varying_rho_service_distributions():\n",
    "    \"\"\"\n",
    "    Runs simulations for different service distributions with varying system load (rho).\n",
    "\n",
    "    Returns:\n",
    "    - A plot showing mean waiting times with confidence intervals for each service distribution.\n",
    "    - Prints summary statistics for waiting times.\n",
    "    \"\"\"\n",
    "    service_distributions = ['exponential', 'deterministic', 'hyperexponential']\n",
    "    num_runs = 20\n",
    "    system_loads = np.linspace(0.4, 0.99, 10)\n",
    "    durations = 100000 * np.ones_like(system_loads)\n",
    "    durations[7:] *= 5\n",
    "    \n",
    "    rand.seed(42)\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    \n",
    "    waiting_times = {service_type: [] for service_type in service_distributions}\n",
    "    \n",
    "    for service_type in service_distributions:\n",
    "        mean_wait_time = np.zeros_like(system_loads)\n",
    "        std_wait_time = np.zeros_like(system_loads)\n",
    "        \n",
    "        # Loop over different system loads (rho values)\n",
    "        for i, system_load in enumerate(system_loads):\n",
    "            sim_duration = durations[i]\n",
    "            wait_times = np.zeros(num_runs)\n",
    "            \n",
    "            # Run multiple simulations to collect data for statistical analysis\n",
    "            for j in range(num_runs):\n",
    "                seed = rand.randint(0, 2**31 - 1)\n",
    "                \n",
    "                # Define service distribution based on type\n",
    "                if service_type == 'exponential':\n",
    "                    service_dist = lambda: rand.exponential(1 / (1 / system_load))\n",
    "                elif service_type == 'deterministic':\n",
    "                    service_dist = lambda: 1 / (1 / system_load)\n",
    "                elif service_type == 'hyperexponential':\n",
    "                    def service_dist():\n",
    "                        if rand.rand() < 0.75:\n",
    "                            return rand.exponential(2/system_load)\n",
    "                        else:\n",
    "                            return rand.exponential(2/(5*system_load))\n",
    "                else:\n",
    "                    raise ValueError(\"Unsupported service time distribution\")\n",
    "                \n",
    "                # Run the simulation and record the average waiting time\n",
    "                res = M_X_n_simulation(system_load, 1, sim_duration, seed=seed, service_dist=service_dist)\n",
    "                wait_times[j] = res['Average Wait Time']\n",
    "            \n",
    "            # Store waiting times for statistical analysis\n",
    "            waiting_times[service_type].extend(wait_times)\n",
    "            \n",
    "            # Calculate mean and standard deviation of waiting times for the current system load\n",
    "            mean_wait_time[i] = np.mean(wait_times)\n",
    "            std_wait_time[i] = np.std(wait_times)\n",
    "        \n",
    "        # Plotting mean waiting time with confidence intervals for the current service distribution\n",
    "        plt.errorbar(system_loads, mean_wait_time, \n",
    "                    yerr=1.96 * std_wait_time / np.sqrt(num_runs), \n",
    "                    linestyle='', label=f'{service_type.capitalize()}', capsize=5, elinewidth=1)\n",
    "\n",
    "    # Configure plot appearance\n",
    "    plt.grid()\n",
    "    # plt.xscale('log')\n",
    "    plt.yscale('log')\n",
    "    plt.xlabel(r'$\\rho$', fontsize=14)  # Update to use rho\n",
    "    plt.ylabel('Mean Wait Time', fontsize=14)\n",
    "    plt.xticks(fontsize=12)\n",
    "    plt.yticks(fontsize=12)\n",
    "    plt.legend(title='Service Distribution', title_fontsize=12, fontsize=12)\n",
    "    plt.title(r'Mean Wait Time vs System Load ($\\rho$) for Different Service Distributions')\n",
    "    plt.savefig('plots/4).png', dpi=600)\n",
    "    plt.show()\n",
    "\n",
    "\n",
    "    # Output all data points for each distribution\n",
    "    print(\"\\nAll Data Points for Waiting Times:\")\n",
    "    for service_type in waiting_times:\n",
    "        print(f\"{service_type.capitalize()} Waiting Times: {waiting_times[service_type]}\")\n",
    "\n",
    "    # Print summary statistics for each distribution\n",
    "    means = {}\n",
    "    std_devs = {}\n",
    "    for service_type in waiting_times:\n",
    "        mean_wait = np.mean(waiting_times[service_type])\n",
    "        std_wait = np.std(waiting_times[service_type])\n",
    "        means[service_type] = mean_wait\n",
    "        std_devs[service_type] = std_wait\n",
    "        print(f\"{service_type.capitalize()} - Mean Waiting Time: {mean_wait:.4f}, Std Dev: {std_wait:.4f}\")\n",
    "\n",
    "    # Kruskal-Wallis test to check if there are significant differences between the average waiting times\n",
    "    h_stat, p_value = stats.kruskal(waiting_times['exponential'], waiting_times['deterministic'], waiting_times['hyperexponential'])\n",
    "    print(f\"\\nKruskal-Wallis H-statistic: {h_stat:.4f}, p-value: {p_value:.4g}\")\n",
    "\n",
    "    # Mann-Whitney U-tests to further analyze differences between distributions\n",
    "    u_exp_det, p_exp_det = stats.mannwhitneyu(waiting_times['exponential'], waiting_times['deterministic'], alternative='two-sided')\n",
    "    u_exp_hyper, p_exp_hyper = stats.mannwhitneyu(waiting_times['exponential'], waiting_times['hyperexponential'], alternative='two-sided')\n",
    "    u_det_hyper, p_det_hyper = stats.mannwhitneyu(waiting_times['deterministic'], waiting_times['hyperexponential'], alternative='two-sided')\n",
    "\n",
    "    print(\"\\nMann-Whitney U-tests Results:\")\n",
    "    print(f\"Exponential vs Deterministic: U-statistic = {u_exp_det:.4f}, p-value = {p_exp_det:.4g}\")\n",
    "    print(f\"Exponential vs Hyperexponential: U-statistic = {u_exp_hyper:.4f}, p-value = {p_exp_hyper:.4g}\")\n",
    "    print(f\"Deterministic vs Hyperexponential: U-statistic = {u_det_hyper:.4f}, p-value = {p_det_hyper:.4g}\")\n",
    "\n",
    "# Example Usage\n",
    "run_simulations_varying_rho_service_distributions()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
